% !TeX spellcheck = <none>
\chapter{\docname}
In diesem Kapitel wird feiner beschrieben, wie der Gesichtsregistrierungsteil funktioniert.
\label{\docname}
\section{Umsetzung}
Hier wird erkl\"art, wie es gedacht ist, den Gesichtsregistrierungsteil zu implementieren. 
\subsection{Allgemein}
Sicherheit ist heutzutage hoch interessant und relevant in mehreren technischen und nicht technischen Bereichen. Sicherheit ist eigentlich relativ, niemand wei\"sst, ob er sicher ist oder nicht. Aber es gibt Systeme, bzw. Ger\"ate, Personen usw., die Sicherheit garantieren. Das System, das entwickelt wird, hat mit Gesichter von Personen zu tun. Alle wissen, dass das Gesicht f\"ur jede Person anders ist. Jede Person wird mit ihrem Gesicht identifiziert, weil es einzigartig ist. Das Gesicht hat Daten, die von verschiedenen Algorithmen herausgeholt werden k\"onnen, und sie f\"ur Realisierung der \"uberpr\"ufung und Identifizierung der Personen verwenden zu k\"onnen. 

Das System ist in zwei Teile geteilt. Es gibt den Registrierungsteil und den Erkennungsteil. Bei dem Registrierungsteil wird die komplette Registrierung der Sch\"uler und Sch\"ulerinnen, der Lehrer und Lehrerinnen gemacht. 

Das andere Paket namens „git“ ist f\"ur das System nicht notwendig, aber git k\"onnte als eine Backup-Strategie verwendet, wenn das System abst\"urzt. Git ist ein Versionsverwaltungssystem, das verschiedene Versionen bzw. Commits auf einem Github-Server speichert. Auf dem Github-Server gibt dann verschiedene Versionen des Systems und die Daten werden von einem bestimmten Commit dann zur\"uckgeholt. Es wird meistens bei der Implementierung-Phase verwendet, um die Ver\"anderungen der Source-Code, wann ge\"andert hat, wer ge\"andert hat, deutlich zu sehen.
Cmake ist ein Paket, das gebraucht wird, wenn das System mit OpenCV-Framework arbeitet wird. Es muss das System so konfiguriert sein, damit das OpenCV-Framework in einem C++ Programm verwendet werden kann. Deshalb brauchen wir spezielle cmake Befehle, die es erm\"oglichen.

"CMake wird verwendet, um den Softwarekompilierungsprozess mithilfe einfacher plattform- und compilerunabh\"angiger Konfigurationsdateien zu steuern und native Makefiles und Arbeitsbereiche zu generieren, die in einer Compilerumgebung Ihrer Wahl verwendet werden k\"onnen."\cite{cmake}

Das gleiche passiert auch, wenn z.B. Python statt C++ verwendet wird. Die anderen Pakete wie z.B. libgtk2.0-dev pkg-config, libavcodec-dev, libavformat-dev, libswscale-dev, sind n\"otige Paketen, damit das OpenCV-Framework eigentlich verwendet kann. 
 \subsection{Technische L\"osung}
Technologien, die ich f\"ur die Implementierung verwendet habe sind: 
\begin{itemize}
	\item Linux als Betriebssystem \cite{Linux_Betriebssystem}  \\
	Linux ist das weit verwendete Betriebssystem der Welt. Es ist eine open-source Software. Linux ist flexibel, man kann die einzelnen Modulen wegnehmen, ohne dass das Betriebssystem abst\"urzt. Der Benutzer kann auch die Kernkomponenten w\"ahlen wie z.B. welches System-Grafiken angezeigt werden, bzw. die ganzen Komponenten der Benutzeroberfl\"ache. Warum ich Linux gew\"ahlt habe, gibt es verschiedene Gr\"unde. Linux ist f\"ur eingebettete Systeme sehr geeignet. Es ist sicher gegen Schadprogrammen, Viren, Trojanern. Linux ist einfacher. Vorher war ein kompliziertes System, jetzt seit den Bem\"uhungen der Ubuntu-Fundationen und der Ubuntu-Distribution ist es sehr einfach verwendbar.\\
	\item Python
	"Python ist eine Programmiersprache, die 1991 ver\"offentlicht wurde. Python besitzt eine einfache Lesbarkeit und eine eindeutige Syntax. Python l\"asst sich leicht erlernen und unter UNIX, Linux, Windows und Mac OS verwenden." \cite{python} Warum Python gew\"ahlt wurde, hat verschiedene Gr\"unde. Python hat weniger Schl\"usselw\"orter, reduziert die Sytax auf das Wesentliche und optimiert die Sprache. Ein Programm, das in Python geschriebt ist, ist vom Betriebssystem unabh\"angig. Das bedeutet, sie k\"onnen Plattform unabh\"angig interpretiert werden. Python hat auch eine gute Lesbarkeit. \\ 
	
	
\end{itemize}
Das System besteht aus verschiedenen Terminatoren.
"Ein  Terminator  befindet  sich  au\"sserhalb  des  zu  definierenden  Systems.  Es  kann  eineandere Person, System oder eine Organisation sein. Terminatoren k\"onnen von unseremSystem Informationen, Nachrichten, Materialien oder Energie erhalten oder das Systemempf\"angt diese."\cite{terminator}

Der wichtigste Terminator ist der "Register-Schalter". Er initialisiert das ganze Programm. Schalter in Technik ist nichts anders, nur ein Ger\"at zum Ein- und Ausschalten des Stroms oder zum Leiten des Stromflusses. Wenn der Schalter gedr\"uckt wird, bekommt das System einen Input, transformiert und gibt dann einen Output. Das System ist sehr einfach verwendbar.

Das Register-LED dient als einen Anzeiger. Wenn mit dem System etwas nicht stimmt, z.B. nicht richtige Inputdaten, dann wird mit einer bestimmten Farbe geleuchtet, n\"amlich mit rot. Wenn etwas passt, dann wird mit gr\"un geleuchtet. Eigentlich das normale LED hat nur eine Farbe, aber es wird ein spezielles LED verwendet, namens RGB LED. RGB LED hat drei Grundfarben, rot, gr\"un, blau, und mit diesen drei Farben kann man alle Farben erstellen. Es k\"onnte auch zwei LEDs geben, rot und gr\"un, aber es ist effektiver, ein RGB LED zu verwenden.

Eine spezielle Eigenschaft des Systems ist die Verwendung einer Tastatur. Sie wird verwendet, weil die einzelnen Personen ihren Namen, bzw. Email schreiben m\"ussen. 
Die andere spezielle Eigenschaft ist die Verwendung eines LCD-Screens. Da werden z.B. Errors gezeichnet, die Daten, die in Log gespeichert sind usw. Es ist leicht auch f\"ur den Benutzer zu sehen, dass es z.B. ein Problem mit dem System gibt, damit er nicht vor der Kamera warten muss. Eigentlich die Hauptfunktion des LCD-Screens ist, alles was der Benutzer mit der Tastatur schreibt, da zeigen zu lassen. Warum es so geplant ist? Das Problem steht daran, wenn der Benutzer seine Email schreibt, kann er Fehler machen, weil er nicht sieht, was er schreibt. Um das zu vermeiden, wird das LCD-Screen verwendet, damit der Benutzer sehen kann, was er schreibt.

Um registrierte Personen mit ihren Gesichtsdaten zu speichern, braucht das System einen Server. In diesem Server l\"auft ein Datenbank Management System, in dem eine Datenbank erstellt ist. Die Datenbank ist so konfiguriert, damit die Person mit ihren Infos gespeichert werden k\"onnen. Um die Verbindung zwischen System und Server zu erm\"oglichen, wird das Paket „python-mysqldb“ verwendet.

Das System hat auch einen Backup-Server. Die Daten werden parallel bei dem Hauptserver sowie bei dem Backup-Server gespeichert, damit die Daten noch gesichert sind, wenn der Hauptserver ein Problem hat. Die Verwendung des Backup-Servers ist zustande gekommen, weil das System 24/7 arbeiten muss, und wenn der Hauptserver Maintenance oder Probleme hat, der Backup-Server arbeiten kann. Auf dem Abb. \ref{fig:1Ebene_Gesichtsregistrierung} k\"onnen Sie in einem technischen Weg besser sehen, wie der Gesichtsregistrierung-Teil arbeitet.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures 1Ebene.png}
	\caption{Structed Software Design bzw. erste Ebene }
	\label{fig:1Ebene_Gesichtsregistrierung}
\end{figure}
Um Schalter und LEDs im System verwenden zu k\"onnen, brauchen wir ein spezielles Paket namens „RPi.GPIO“. Dieses Paket macht es m\"oglich, den Raspberry PI mit HW (LED und Schalter) verbinden zu k\"onnen. Daf\"ur werden GPIOs verwendet. Der Schalter hat 3 Beine. Eines wird mit 5V verbunden, das andere mit Ground und das andere ist f\"ur Daten. Dies wird dann mit einem GPIO-Port in Raspberry PI verbunden. Das gleiche ist auch f\"ur die LED, damit es von Raspberry PI kontrollieren verwenden kann, wird mit einem GPIO-Port verbunden. Mithilfe dieser GPIO-Ports bekommt das System zur\"uck, wenn der Schalter gedr\"uckt wird. Wert „1“ ist der Schalter gedr\"uckt und werden dann die verschiedenen Skripten aufgerufen. 

Schritte: 
\begin{enumerate}
	
	\item Am Beginn des Skripts diese Zeile schreiben: "\#!/usr/bin/python". Es gibt zwei Gr\"unde, warum diese Zeile geschreibt wird. Der erste Grund ist, dass dieses Program mit einem Python-interpreter ausgef\"uhrt wird, der zweite ist, Verwendung des Programmsuchpfads, um es zu finden. \\ \\ \\ \\ \\ \\ \\ \\ 
	 \item Alle Paketen importieren. Sehen Sie auf Abb. \ref{fig:Packages zu importieren} 
	 \begin{figure}[H]
	 	\includegraphics[width=\textwidth]{\ordnerfigures Import_Packages.png}
	 	\caption{Packages zu importieren im Main-Skript}
	 	\label{fig:Packages zu importieren}
	 \end{figure}
	 \begin{itemize}
	 	
	 \item RPi.GPIO ist ein Paket, das verwendet wird, um Zugriff auf die sogennanten GPIO-Ports zu haben. Vorher habe ich erw\"ant, wenn wir Zugriff auf die HW-Komponenten haben wollen, die mit Raspberry PI verbunden sind, brauchen wir die GPIO-Ports. Um diese GPIO-Ports in Python zu verwenden, brauchen wir das sogennante Paket "RPi.GPIO". Es gibt verschiedene Pakete, die einen Zugriff zwischen GPIO-Ports und Python erm\"oglichen, wie z.B. rpi.gpio, GPIOZero usw. Es wird das rpi.gpio Paket verwendet, weil es leicht verst\"andlich, programmierfreundlich und einfach zu verwenden ist. \cite{rpigpio}
	 
	 \item time ist ein Paket in Python. Von diesem Paket wird nur die Funktion 'sleep' verwendet. Diese Funktion pausiert das python-Programm. \cite{timepackage}
	 
	 \item os ist das wichtigste Paket in unserem Skript. Es erlaubt mir, dass ich in einem Python-Skript andere Skripten aufrufen kann. Es ist egal, in welcher Programmiersprache diese Skripten geschrieben sind. Es gibt auch verschiedene Methoden, wie man verschiedene Skripten in einem Python-Skript aufrufen kann. Man macht mit dem subprocess Paket, eine Main-Funktion in dem Skript machen und hier die verschiedenen Funktionen des anderen Skripts aufrufen. 
	 
	 \item subprocess Paket dient zur Verbindung zwischen verschiedenen Prozessen, in meinem Fall, ein Prozess hei\"sst, ein Aufruf eines Skriptes, aber wird nicht im Skript verwendet. 
	 
	 \item Das sys Paket wird verwendet, um Console Parameter zu geben. Das bedeutet, wenn der Skript aufgerufen wird, z.B. login.py dann nach dem login.py gebe ich einen Parameter mit login.py $<$parameter $>$ \\ \\ \\ \\ \\ \\ \\ \\ \\ 
   \end{itemize}
	\item GPIO-Ports direction einrichten. Direction f\"ur LED ist 'out', weil das LED als ein Output f\"ur unseres System dient. Direction f\"ur Schalter ist 'in', weil der Schalter als ein Input f\"ur unseres System dient. Auf Abb. \ref{fig:GPIO-Ports Konfiguration} ist auch der Python-Code.
	\begin{figure}[H]
		\includegraphics[width=\textwidth]{\ordnerfigures GPIO_PORTS_Einrichten.png}
		\caption{GPIO-Ports Konfiguration}
		\label{fig:GPIO-Ports Konfiguration}
	\end{figure}
	Es gibt verschiedene Betriebsarten f\"ur GPIO wie BCM und Board.
	Ich verwende BCM (Broadcom Pin Number), weil ich das Paket RPi.GPIO verwende. Mit diesem Paket darf nur die Betriebssart 'BCM' verwendet werden. 
	\cite{gpiomode}
	F\"ur die Registrierung der Sch\"uler und Sch\"ulerinnen bzw. Lehrer und Lehrerinnen ist es n\"otig, dass der Admin physisch da ist. Die \"uberpr\"ufung, ob der Admin da ist oder nicht,  wird mit einem Vergleich von zwei Bilder gemacht. Ein Bild von Admin ist gespeichert, das andere wird gemacht, indem ich das Skript, das Bild macht, aufrufe, und dann vergleiche ich mit einem anderen Skript diese beide Bilder. Es gibt 'matched' zur\"uck, wenn die Gesichte bei den beiden Bildern gestimmt haben und 'not matched' wenn die Gesichte nicht gestimmt haben.
	\item Dann kommt der Teil "Input check". 
	Hier dann verwende ich die Methode 'input'. Die Methode befindet sich im Paket 'RPi.GPIO' und gibt entweder true oder false zur\"uck. 
	Im Verzeichnis '/sys/class/gpio/gpio$<$GPIO-PORT$>$ gibt es zwei Dateien, value and direction. Direction f\"ur die Port des Schalters ist IN und f\"ur die Port des LEDs ist OUT. Mit der Methode 'input' hole ich das Wert (value) der Schalter-Port. Wenn der Schalter gedr\"uckt wird, wird der Wert '1' herausgekommt und 1 repr\"asentiert 'true' Das bedeutet, Input-methode liefert 'true' zur\"uck und das Programm l\"auft weiter.
	
Nachdem der Schalter gedr\"uckt wird, wird ein Skript aufgerufen. Dieses Skript dient zur Registrierung der Person in der Datenbank.
F\"ur die Registrierung der Sch\"uler und Sch\"ulerinnen bzw. Lehrer und Lehrerinnen ist es n\"otig, dass der Admin physisch da ist. Ist der Admin da, k\"onnen die Personen mit der Registrierung beginnen.
Diese Person wird nach ihrem Vornamen, Nachnamen, Email und Rolle gefragt. Die Rolle schreibt der Admin. 1 ist f\"ur Admin, 2 f\"ur Sch\"uler und 3 f\"ur Lehrer und Lehrerinnen. Die E-Mail speichere ich dann in einer Variable und diese Variable \"ubergebe ich dann bei einem anderen Skript. Dieses Skript dann erstellt mit der Kamera eine Verbindung und macht ein Bild. Der Name des Bildes ist gleich mit der Email der Person. Es ist so gew\"ahlt, weil es f\"ur das Einf\"ugen der Daten in der Datenbank und bei der Speicherung des Paths des Bildes in der Datenbank mit dem gleichen Namen wie E-Mail einfacher ist.

Es wird die E-Mail verwendet, weil es eine performantere Suche in der Datenbank erm\"oglicht. Die E-Mail ist einzig, nur einmal f\"ur jede Person und die SQL-Anweisung (select-Abfrage) eine Selektion durchf\"uhrt. Von 1000 Datens\"atze wird nur der Datensatz ausgegeben, in dem die E-Mail mit der eingetippten E-Mail vom Benutzer \"ubereinstimmt.

% Prej itu duhet me fillu me ndryshu un
Anschlie\"ssend, wenn die Person in der Tabelle 'person' gespeichert ist, hole ich ID dieser Person und f\"uge dann diese ID mit der E-Mail und Path des Bildes in der Tabelle 'info' ein. Sehen Sie auf Abb. \ref{Python-Code}, wo einen Code in Python dargestellt ist. 
\end{enumerate}
\begin{figure}
\caption{Beispiel in Python, wie die Personen registriert werden}
\label{fig:Python-Code}
\begin{lstlisting}
def insertPath(mycursor):
mycursor.execute("select idP from person where email='%s';"%(variable3))
myresult=mycursor.fetchall()
for x in myresult:
var1=x[0]
mycursor.execute("insert into info(imagePath,idP) values('%s',%s);"%('./'+variable3+'.jpg',var1))

\end{lstlisting}

\end{figure}
\subsection{Herausforderungen}
Eigentlich hatte das Projekt f\"ur mich viele Herausforderungen. Die Gr\"unde daf\"ur sind, weil es ein ziemlich gro\"sses Projekt ist, haben wir neue Technologien verwendet, die wir vorher nie verwendet haben. Ich habe keine Erfahrung z.B. mit OpenCV, Python und viele verschiedene Dinge, die ich sp\"ater erw\"ahnen werde. Ich habe von diesen Herausforderungen und Problemen viel gelernt. Einerseits bin ich froh, anderseits bin ich w\"utend, weil das Datum des Ende des Projekts verz\"ogert ist. 
Die Herausforderungen waren:

\begin{itemize}
	\item opencv zu installieren. Das war eigentlich die gr\"o\"sste Herausforderung. Es hat mir 3 Woche gedauert, bis ich es installiert habe. 
	
	\item Beginn des Projektes. Immer der Beginn eines Projektes ist schwierig. Die Koordination im Team war sehr schwierig. Ich, als Projektleiter, musste allen sagen, wie sie arbeiten sollen, wo sie die Dateien finden k\"onnen usw. Das war eine richtige gro\"sse Herausforderung
	
	\item Git repository, Einrichtung von git. Manche von den Teammitgliedern wussten sehr wenig von git und ich musste es ihnen erkl\"aren. Manchmal gab es merge conflicts, weil sie pull gemacht haben, ohne dass Sie die \"anderungen commited haben. Ich sollte alle diese l\"osen, weil ich mehr Erfahrung mit git hatte. 
	
	\item Python als Programmiersprache. Wir wollten vorher mit C++ es machen, aber es war sehr schwierig, OpenCV in Visual Studio zu installieren. Manche von uns wollten in Windows arbeiten und der einzige Weg war, mit Visual Studio zu arbeiten. Es ist nicht gegangen, deshalb sind wir zu Python gewechselt. Wir haben Python gew\"ahlt, weil opencv in Python sehr einfach installierbar war. Mit Python hatten wir keine gro\"sse Erfahrung. Das Maximum, was ich mit Python gemacht habe ist, eine Verbindung mit der Datenbank und Statements schicken (Insert,Select,Update,Delete). Alle andere Wissen sollte ich selbst von B\"ucher, Internet, Tutorials lernen. Die gro\"sse Herausforderung hier war, die richtigen Quellen zu finden.
	
	\item Verwendung der Kamera und verbinden mit Python. Ich wusste nicht, welche Funktionen man verwendet, um die Verbindung mit der Kamera zu erstellen. 
	\item Bei der \"alteren Version von Raspbian hei\"sst das Paket, das python mit Datenbank Managment System(MySQL) verbindet, 'python-mysqldb' und jetzt hei\"sst es 'python-mariadb'. Ich wusste das nicht und hat mir ein bisschen Zeit gekostet.
	\item Abh\"angigkeiten zwischen einzelnen Arbeitsteilen. Die Aufgaben sind so geteilt, dass sie Abh\"angigkeiten zwischen einander liegen. Das hat dann zu einer Versp\"atung der Projektabgabe gef\"uhrt, weil jeder Teammitglieder aufeinander warten mussten. 
	\item Was ich geplant habe, hat nicht gut funktioniert. Die gro\"ssen Teile meiner Planung haben gepasst, nur wenige Kleinigkeiten musste ich \"andern. Sie sind erst in der Implementierungsphase angezeigt.
	\\
	\\
	
Ich habe diese L\"osungen f\"ur die Herausforderungen gefunden: 
\begin{enumerate}
	\item Ich habe viel Tutorials geschaut, Websites gesehen, wie opencv in Raspberry PI installiert werden kann. Ich habe viele verschiedene Methoden probiert,aber mit keinem guten Ergebnis. Nach vielen Proben ist es gegangen. Es ist installiert, und habe ich dann verschiedene Skripte in python gemacht, um es zu testen. Manche der Skripte sind gegangen, manche nicht. Jetzt war eine kleine Herausforderung f\"ur mich, dass ich die Skripte, die nicht ausgegangen sind, verbessere. Anschlie\"ssend habe ich herausgefunden, dass das Problem bei dem Kompilieren von opencv war (cmake). Ich habe es noch einmal vom Beginn kompiliert. Jetzt ist alles in Ordnung, alle Skripte arbeiten, keinen Fehler mehr, der mit opencv Paket zu tun hat.
	
	\item Ein Treffen mit meiner Gruppe vor dem Beginn des Projektes war notwendig. Ich hab es Ihnen gesagt und erkl\"art, in welchen Verzeichnise sie arbeiten sollten, die Struktur der Dokumentation, welcher Kommunikationskanal verwenden wir, um Probleme, Herausforderungen usw. zu besprechen usw. Jede Person hatte dann ihre Vorschl\"age, um das so und so zu l\"osen, und dieses Treffen hat zu lange gedauert, bis alle verstanden hatten, wie, wo,was, wann machen sollen. Aber auch nach dem Treffen gab es zwischendurch Missverst\"andisse bzw. Probleme mit der Kommunikation, z.B. wurde nicht im richtigen Verzeichnis gearbeitet usw. 
	
	\item Ein Git-Repository erstellen und einzurichten war einfach. Ich hab es online in github.com erstellt. Einen Name eingegeben und dann als Collaborators die anderen Teammitglieder hinzugef\"ugt. Um strukturierter zu werden, habe ich dann verschiedene Branches angelegt. Wie immer, gab es mit dem Befehl 'push' und 'pull' wieder Probleme. Das habe ich gel\"ost, in dem ich allen gesagt habe, dass, wenn sie in einem Github-Repository arbeiten m\"ochten,dann bevor dem Beginn der Arbeit, m\"ussen sie ein 'pull' machen, damit die \"anderungen, die von anderen in dem Repository gemacht wurden, mit deiner Version am Computer synchronisiert werden. Sie wissen nie, was die anderen in diesem Repository machen. Sie machen 'push', ohne zu sagen, dass sie ein 'push' gemacht haben. Das f\"uhrt dann zu merge-Probleme usw. 
	
	\item Ich habe jedem Teammitglieder gesagt, er muss mindestens zwei Wochen mit dem Lernen von Python verbringen. Tutorials ansehen, Beispiele selbst probieren, die Quellen daf\"ur selbst finden. 
	
	\item  F\"ur die Verbindung der Kamera mit OpenCV, gibt es einen Skript in der offiziellen Website-Dokumentation von OpenCV. Da habe ich alle Funktionen gesucht und gefunden, die ich brauchte, um die Kamera in Python verwenden zu k\"onnen. 
	
	\item Damit wir die Abh\"angigkeiten zu minimieren, habe ich gedacht, dass jeder Teammitglieder andere Aufgaben bekommt, als die, die in der Dokumentation stehen. Ich war gezwungen, diese \"anderung zu machen, sonst w\"urde das Projekt viel l\"anger dauern. 
	
	\item Bei der Implementierung sind Kleinigkeiten herausgekommen, die bei der Planung nicht ber\"ucksichtigt waren. Die habe ich direkt in der Implementierung verbessert, ohne dass ich nocheinmal die Planung machte. Aber ich habe diese Kleinigkeiten zur Kenntnis genommen, damit ich keinen solchen Fehler(Kleinigkeiten) mehr in der Planungsphase machen werde. 
 \end{enumerate}
\end{itemize}
\subsection{Qualit\"atssicherung und Controlling}
Ein Risiko ist meistens nur ein Einsch\"atzung, was kostet es einem Unternehmen, wenn die Projektziele nicht erreicht werden. Ich, als Projektleiter, muss das machen. Eine Risikoanalyse zu planen ist sehr schwierig, weil es mit der Zukunft zu tun hat. Zuerst muss ich an die Zukunft denken, bei welchen Bauteilen z.B. k\"onnen Fehler auftreten, welche Programme k\"onnen ausfallen. Das bedeutet, ein \"uberblick an der Zukunft und einsch\"atzen, was f\"ur Fehler und Risiken es geben kann. Dann sch\"atze ich die Wahrscheinlichkeit ihres Eintretens und am Ende die Ma\"ssnahmen. Dahinter versteckt sich eine gro\"sse Arbeit.\cite{Risikoanalyse} 
Auf Abb. \ref{fig:Risikoanalyse} k\"onnen Sie die Risikoanalyse sehen. Wahrscheinlichtkeit, Kosten usw. alles sollen beachtet werden.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures Risikoanalyse1.png}
	\includegraphics[width=\textwidth]{\ordnerfigures Risikoanalyse2.png}
	\caption{Risikoanalyse in Excel}
	\label{fig:Risikoanalyse}
\end{figure}

\section{Ergebnisse}
Es sind 3 Monaten vergangen, seit ich angefangen habe zu arbeiten. Weil meiner Teil nicht viel Hardware hatte, nur ein LED, einen Schalter, Tastatur, war es nicht schwierig, die mit dem ganzem System zusammenzusetzen. Bis jetzt ist es gedacht, dass das System keine LCD Anzeige haben wird, weil ich nicht viel Zeit habe, um sie zu programmieren. Statt LCD Anzeige wird einen Bildschirm verwendet. 
\subsection{Implementierung}
Nachdem eine gro\"sse und gute Arbeit meinerseits, befindet sich das Produkt in der Inbetriebnahme-Phase. Das bedeutet, bis jetzt gibt es einen Prototyp. Ich habe f\"ur diesen Prototyp die sogennante Kernfunktionen implementiert. Kernfunktionen sind Grundfunktionen bzw. wesentliche Funktionen, ohne denen nichts geht. Die Funktionen, die in diesem Prototyp implementiert sind, sind folgende:
\begin{itemize}
	\item Admin Account. Wenn sich eine Person registriert m\"ochtet, dann muss sich der Admin sich einloggen. F\"ur diesen Prototyp gibt es nur ein Passwort, damit der Admin erkannt wird. Auf dem anderen Prototyp wird es kein Passwort geben, sondern die \"uberpr\"ufung wird durch den Gesichter-Vergleich erfolgt.
	\item Eine Person wird mit ihrem Vorname, Nachname, Email und Role in der Datenbank gespeichert
	\item Ein Bild von einer Person wird gemacht, und in der Datenbank speichern mit der ID der Person speichern
	\item Wenn die Person erfolgreich in Datenbank gespeichert wird, leuchtet die LED.
\end{itemize}
