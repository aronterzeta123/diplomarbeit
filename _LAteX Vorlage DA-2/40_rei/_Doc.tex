\chapter{\docname}
% !TeX spellcheck = de_DE
\label{\docname}
Am Beginn wird eine allgemeinere Übersicht dieses Diplomarbeitskapitels gemacht bzw. dargestellt, damit verstanden wird, worum es in diesem Teil geht.
\section{Allgemeines}
%In der heutigen Zeit ist die Technologie eines der wichtigsten Themen für die Welt. Mithilfe der Technologie hat die Menschheit wesentliche Fortschritte gemacht im Bereich der Lebensqualitätsverbesserung und -erleichterung. Mehr als jemals zuvor kommen intelligente Systeme zum Einsatz, die den Arbeitsaufwand und die Arbeitskomplexität reduzieren. Diese Systeme werden in den wichtigsten Bereiche des Lebens verwendet, wie zum Beispiel: Menschlichen Beziehungen, Business, Transport, Banken, Medizin, Bildung und Kommunikation. Selbstverständlich gibt es zahlreiche Versuche von verschiedenen Menschen, auf diesen Systemen zu zugreifen. Deshalb ist die Sicherheit in diesen Systemen eine der aktuellsten und wichtigsten Themen. Der unkontrollierte Zugriff auf solche wichtigen und delikaten Systeme würde zu fatalen Konsequenzen führen. Aus diesem Grund muss sehr genau und detailliert geplant werden, welche Sicherheit Strategien die klügsten bzw. die Besten sind.   

%Das Hauptthema dieses Projekts ist genau die Sicherheit der Systeme, und zwar die Ermöglichung des kontrollierten Zugriffs von Menschen in verschiedenen Gebäuden. Es wurde die Verantwortlichkeit übernommen, der Zugriff in der Österreichischen Schule “Peter Mahringer” überwiesen und kontrolliert zu machen. Zu diesem Zweck wird in diesem Projekt ein intelligentes System entwickelt, dass die Aufgabe hat, menschliche Gesichter (Gesichtern von Schülern, Lehrern, Eltern usw.) zu registrieren und zu erkennen. Es wird höchstwahrscheinlich in der Schultür integriert, weil dort müssen alle Personen unbedingt vorbeigehen. Dieses Projekt wird eine große Hilfe für die Schule sein, aufgrund der von Kameras und komplexen Algorithmen angebotenen Möglichkeiten. Beispielweise wird es überprüft, ob die Person, die reinkommt ein Student oder Lehrer ist, oder es wird notiert, wer die Schule wann verlässt oder besucht. Hat eine Person kein Zugriff, wird sie nicht herein gelassen.

%Um dieses Projekt zu realisieren, wird das Projekt in drei große und wichtige Teile zerlegt. Das erste Teil heißt Bildverarbeitung und hat die Aufgabe, Gesichtsbildern von der Kamera zu normalisieren und zu verarbeiten, damit sie in geeigneten Format für den Gesichtsvergleichung sind. Der zweite Teil beschäftigt sich mit der Registrierung der Gesichter von Personen am Server. Der dritte Teil ist die Gesichtserkennung. Hier geht es um die Erkennung der Gesichter der Benutzer des Systems. 
Die Gesichtserkennung ist der Teil des Systems, mit dem ich mich beschäftige.
Es wird durch einen Vergleich von Bildern überprüft, ob die Person vorher schon registriert worden ist oder nicht, und ob sein Gesichtsdaten schon am Server existieren oder nicht. Nur wenn die Vergleichsergebnisse positiv sind, wird die Person erkannt.
Der Person werden die Ergebnisse durch Anzeiger kommuniziert. Dieses Teil des Projektes erfordert eine Arbeit mit Datenbanken, Gesichtsvergleichsalgorithmen und mit vielen Systemtests. Teil meiner Aufgabe ist auch der Aufbau des Systems und alles was mit Hardware zu tun hat. Alle Hardware Komponenten werden in den folgenden Kapiteln klar, verständlich und deutlich erklärt. Eine grobe Skizze des Systems ist in Abb.\ref{fig:grobe_Skizze} zu sehen.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures Capture.png}
	\caption{Grobe Skizze des Systems}
	\label{fig:grobe_Skizze}
\end{figure}
\section{Technische Lösung}
In diesem Abschnitt wird eine feinere und detaillierte Übersicht im Bezug auf die technische Lösung gegeben. Alles was mit Technik zu tun hat, wird hier erklärt.
\subsection{Hardware und Aufbau}
Zuerst wird der Aufbau des Systems beschrieben, zusammen mit allen Komponenten, die zu verwenden sind. Ohne die Hardware würde nichts funktionieren, weil die Software ohne die Hardware nicht funktionieren kann.
\subsubsection{Bauteile und HW-Komponenten}
Die Bauteile, die für dieses System verwendet worden sind, sind die folgende:
\begin{enumerate}
	\item \textit{Steckboard bzw. Steckplatine}\\ 
	Die Steckplatine ist eine Komponente der Hardware des Systems. Sie wird für die Entstehung der elektrischen Verbindung von verschiedenen elektrischen Bauteile benötigt, um elektrische Schaltungen zu bauen oder um verschiedene Tests und Experimenten zu machen. In dieser Steckplatine werden alle anderen Komponenten platziert, damit die Verbindung erstellt werden kann und damit das System funktionieren kann.
	\item \textit{Kabel bzw. Leiter} \\
	Damit die verschiedenen Komponenten, die in der Steckplatine platziert sind, miteinander verbunden werden können, braucht man unbedingt Kabel. Mithilfe von Kabeln können elektrische Impulse und Signale fließen, damit die Energie und die Information übertragen werden. Die verwendeten Kabel sind aus Kupfer und vom Typ Male-Male als auch vom Typ Male-Female. Die Kabeln vom Typ Male-Female werden verwendet, um die Verbindungen zwischen den Elemente in der Steckplatine und dem Raspberry Pi zu ermöglichen. Auf der anderen Seite werden die Male-Male Kabeln verwendet um die Verbindungen innerhalb der Steckplatine zu ermöglichen.
	\item \textit{LEDs}\footnote{Light Emitting Diode} \\
	LEDs sind elektronische Halbleiter Elemente, die Licht produzieren können, wenn sie Spannung kriegen. Ein LED besteht aus zwei Beinen. Das längere Bein ist die Anode, die den Pluspol symbolisiert. Das andere Bein ist die Kathode und symbolisiert den Minuspol. Durch die Beine wird der Kontakt mit der Steckplatine hergestellt.\cite{Led}
	\item \textit{Widerstand} \\
	Ein Widerstand ist ein elektrisches Bauteil, das zur Reduzierung von Strom verwendet wird, damit ein Gleichgewicht zwischen Strom und Spannung gesichert werden kann. Die Einheit ist Ohm.\cite{Widerstand}
	\item \textit{Taster} \\
	Ein Taster wird wie ein Schalter gedrückt, mit dem Zweck Impulse oder Signale zu schicken. Im Gegenteil zu einem Schalter wird der Taster nach der Betätigung  wieder in der Basiszustand zurückgestellt. Ein Plusleiter, Minusleiter und ein Datenleiter sind bei einem Taster vorhanden.\cite{Taster}
	\item \textit{Raspberry Pi} \\
	Raspberry Pi ist ein Minicomputer, der in diesem Projekt den normalen Computer ersetzt. Der verwendete Raspberry Pi, Version 3, hat 4 USB-Anschlüsse, einem Netzteil, eine SD-Karte, 16 GPIO\footnote{Generated Input Output} Pins und eine VGA Schnittstelle. Die 3.-Bit SD-Karte ist ein wichtiges Element, weil dort alle Daten und Informationen gespeichert sind.
	\item \textit{Bildschirm} \\
	Ein Bildschirm ist eine Anzeige, die für die visuelle Darstellung von verschiedenen Informationen oder Daten(wie Videos, Fotos, Statistiken usw.) verwendet wird. Ein Bildschirm wird zu den heutigen Zeiten sehr häufig verwendet, aufgrund der hohen Benutzerfreundlichkeit, die angeboten wird.\cite{Bildschirm}
	\item \textit{Tastatur} \\
	Eine Tastatur ist ein Input Gerät, dass durch das Drücken von Tastern den Benutzer die Eingabe von Daten oder Befehle ermöglicht.\cite{Tastatur}
	\item \textit{Kamera} \\
	Es wird eine Kamera benötigt, die die Fotos der Gesichter der Personen macht. Sie werden auch im Raspberry Pi integriert bzw. mit dem Raspberry Pi verbunden. Die Kameras sind vom Typ Aukey.
\end{enumerate}
\subsubsection{Schaltplan und Erklärung des Aufbaus}
Die Hardware Komponenten werden in einer Steckplatine platziert. Dort werden die Verbindungen mit den anderen Komponenten sowie mit dem Raspberry Pi hergestellt. Die elektrische Schaltung wird durch einen Schaltplan beschrieben. Dieser Schaltplan wurde mit Hilfe eines Programms, ``Fritzing'', erstellt und spielt eine sehr wichtige Rolle bei der Organisation und Planung des Schaltkreises. Der Schaltplan ist auf Abb.\ref{fig:Schaltplan} zu sehen.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures Schaltplan.png}
	\caption{Schaltplan des Systems}
	\label{fig:Schaltplan}
\end{figure}
Wie der Schaltplan zeigt, besteht das System aus zwei LEDs, zwei Tastern, einem Widerstand, eine Steckplatine und einem Raspberry Pi. Sehr wichtig für den Aufbau der Schaltung sind die GPIO Pins. Diese Pins sind in dem Raspberry Pi platziert und können als Input, als Output oder Spannungpins verwendet werden. 
Der erste Taster dient für die Gesichtsregistrierung und besteht aus einem Pluspol, einem Datenleiter und aus dem Minuspol. Der Pluspol Anschluss wird mittels Steckplatine mit dem 5-Volt Pin des Raspberry Pi verbunden, während der Minuspol-Anschluss mit dem Minuspol der Steckplatine verbunden wird. Der Datenanschluss ist mit dem GPIO18 Pin verbunden. Wie bei dem Registrierungs-Taster wird auch bei dem Erkennungstaster\footnote{Auch als Login Taster genannt} der Minuspol-Anschluss mit einem Pin des Minusbereichs der Steckplatine verbunden. Der Pluspol-Anschluss gehört zu dem 5-Volt Pin des Raspberry PI, während der Datenanschluss mit dem GPIO17 Pin verbunden ist. Die rote LED wird verwendet wenn die Registrierung oder Erkennung der Benutzer im System nicht erfolgreich war. Das längere Bein(die Anode) wird mit dem GPIO23 Pin des Raspberry verbunden, während die Kathode mit dem Minuspol-Bereich der Steckplatine verbunden wird. Die grüne LED ist eine RGB(Red Green Blue) LED. Diese LED kann die Farbe ändern, und wird im Fall einer erfolgreichen Registrierung oder Erkennung des Benutzers im System verwendet. Sie hat im Gegensatz zu der normalen LED 3 Anschlüsse. Der Minus-Anschluss wird mit dem Minuspol Bereich der Steckplatine verbunden und der Pluspol-Anschluss wird mit dem Pluspol Bereich der Steckplatine verbunden. Mit dem GPIO27 Pin des Raspberry wird der Datenanschluss verbunden. Die GPIO Pins sind extrem wichtig für die Integration der Tastern, LEDs und der anderen Bauteile in dem technischen und logischen Teil bzw. in der Software und in den verwendeten Skripten.	
\subsection{Software}
Nachdem der Aufbau und die verwendete Hardware des Systems beschrieben wurden, wird nun die Software beschrieben. In diesem Unterkapitel wird alles was mit dem logische Teil der Umsetzung zu tun hat besprochen: das verwendete Betriebssystem, Programmiersprachen, Frameworks, Technologien und Planungsmethoden. Es wird jede Aufgabe zusammen mit der zugehörigen Lösung im Detail beschrieben und jedes programmierte Skript erklärt.
\subsubsection{Verwendete Technologien}
In diesem Teil des Projekts, das Gesichtserkennung heißt, werden für die Umsetzung 2 verschiedene Technologien verwendet, die in den anderen Teilen nicht oder anders verwendet werden.

%\begin{itemize}
		%\item Linux(Debian) \\
		%Linux ist ein von die wichtigsten Betriebssystemen die zur Verfügung stehen. Linux wird meistens für Programmierungs- und Konfigurationszwecke. Die wichtigsten Bestandteile eines Betriebssystems sind der Bootloader, der Kernel, und das Init System. Linux würde für die Umsetzung dieses Projekts gewählt, obwohl es auch andere Möglichkeiten wie zum Beispiel Microsoft Windows gab. Die Gründe dieser Wahl sind die folgende: 
		%\begin{itemize}
		%	\item Open Source und freie Software \\
			%Linux wurde genutzt, weil es komplett kostenlos benutzt werden kann und weil es ein Open Source Betriebssystem ist. Vorteile eines Open Source Betriebssystems sind die niedrige Kosten, die hohe Sicherheit, die Transparenz und die Zuverlässigkeit. Was noch erwähnt zu werden ist, ist die gute Reputation der Open Source Software, weil nur hoch qualifizierte Entwickler mit ihnen sich beschäftigen.
			%https://wiki.opensourceecology.de/Vorteile/Nachteile_von_Open_Source_Software
		%	\item Hohe Sicherheit \\
			%Für dieses Projekt ist Sicherheit sehr wichtig, und Linux bietet eine hohe Sicherheit. Es gibt keine Viren und sehr kleine Absturz Wahrscheinlichkeiten. Ein Backup ist auch sehr leicht machbar.
		%	\item Vielfältigkeit an Möglichkeiten und Benutzerfreiheit \\
			%Linux wurde auch aufgrund der angebotenen Benutzerfreiheit und Benutzerfreundlichkeit verwendet. Beliebige Systemkonfigurationen, verschiedene Gesichtserkennungspakete(OpenCV\footnote{Open Computer Vision}) und andere Programme oder Technologien(Fritzing) sind von Linux leichter und günstiger erhältlich als bei anderen Betriebssystemen. Endlich ist der Raspberry PI auch kompatibler mit Linux.
			%Als Linux Distribution wurde Debian gewählt. Gründe dafür sind die große Menge der angebotenen Pakete, die hohe Geschwindigkeit und die schnelle Fehlerkorrektur. 
			%\cite{Linux}	
		%\end{itemize}
		
		%\item Python \\
		%Die gewählte Programmiersprache ist Python. Der wichtigste Grund dieser Wahl ist die einfache Verwendung der OPEN-CV Pakete für die Gesichtserkennung Algorithmen. Im Vergleich zu C werden die OpenCV Bibliotheken und Programmen viel leichter und schneller eingebunden. Python hat auch Vorteile im Bezug auf Skripten Einbindung oder Skripten Aufruf, weil ein oder zwei Output Parametern reichen würden, um zwei Skripten miteinander zu verbinden(Variablen, Funktionen usw. importieren). Es wurde Python Version 3 verwendet.
%	\end{itemize}
	%\item \textit{Frameworks} \\
	%In diesem Projekt werden einige Frameworks verwendet, die weiter unten beschrieben werden.
	\begin{itemize}
		\item Open CV \\
		Das wichtigste Framework für dieses Projekt ist OpenCV. OpenCV ist eine Softwarebibliothek, die für Computer-Vision und maschinelles Lernen verwendet wird. Die Bibliothek verfügt über mehr als 2500 optimierte Algorithmen, die sowohl klassische als auch moderne Computer Vision- und maschinelle Lernalgorithmen umfassen. Diese Algorithmen können verwendet werden, um Gesichter zu registrieren und zu erkennen, um Objekte zu identifizieren, menschliche Handlungen in Videos zu klassifizieren und Kamerabewegungen zu verfolgen. Dieses Framework wurde deswegen gewählt, weil die Vielfältigkeit der angebotenen Optionen und Paketen einfach größer ist als bei anderen Frameworks. Ein anderer Vorteil ist das OpenCV Open-Source ist. Die größte Herausforderung ist die lange und komplizierte Installation auf Linux.
		\cite{OpenCVR}
		%\begin{figure}[H]
		%	\includegraphics[scale=0.5]{\ordnerfigures opencv.png}
			%\centering
			%\caption{Open CV\cite{OpenCVBild}}
	%	\end{figure}
		%\item Git \\
		%Git ist ein Versionsverwaltungssystem, das  für das Back-Up des Systems verwendet wurde. Dieses Framework ist ein verteiltes Versionsverwaltungssystem, das heißt, die unterschiedlichen Versionen der Dateien werden effizient gespeichert, in dem die ganze Repository vom Server kopiert wird. Dieses erlaubt dem Benutzer lokal zu arbeiten, und alle Änderungen nachträglich am Server zu aktualisieren. Nicht nur das, sondern auch die hohe Geschwindigkeit der Fehlerfindung und die perfekte Unterstützung von großen Projekten, in dem alle Teammitgliedern auf alle Daten Zugriff haben, waren die Gründe, warum Git für das Back-Up des Systems gewählt wurde.	
%	\end{itemize}
	%\item \textit{Technologien} \\
	%Das System braucht auch ein paar Technologien für die Umsetzung. Unter Technologien versteht man die Programme, die Systeme und die spezielle Komponenten, die benutzt worden sind.
%	\begin{itemize}
	%	\item Raspberry Pi \\
	%	Wie es vorher erwähnt wurde in dem Gesichtserkennung Teil des Projekts statt ein Computer ein Raspberry Pi verwendet. Was ein Raspberry Pi ist wurde in dem Kapitel 7.2.1 erklärt. Die wichtigsten Gründe dieser Wahl werden aber erst jetzt genannt. Der kleinere Platzbedarf und die hohe Flexibilität des Raspberry PI sind wesentliche Vorteile. Die Bestandteile bewegen sich nicht, und es gibt keinen Lärm. Was sehr beliebt ist, ist, dass der Raspberry PI gleichzeitig für die Hardware(GPIO PINS) und die Software(wie ein normaler Computer) verwendet werden kann. Er unterstützt Linux(Raspbian) sehr gut. Ein der wichtigsten Gründe dieser Wahl ist auch, dass im Fall eines Fehlers ein Raspberry PI sehr schnell und problemlos geändert oder repariert werden kann. (Gibt es ein Problem mit der SD-Karte, dann muss sie geändert werden, und dann kann die Hardware wieder ganz normal genutzt werden. Wenn es ein Hardware Problem gibt, dann muss die alte SD-Karte in eine neue SD-Karte kloniert werden und nur ein anderes Raspberry verwendet werden. Somit sind alle Daten gespeichert und es ist möglich, mit Hilfe des anderen Raspberry Pi, sie zuzugreifen)
		\item Fritzing \\
		Fritzing ist ein Programm das für die graphische Darstellung des Schaltkreises des Systems verwendet wurde. Durch dieses Programm wurde auch der Schaltplan des Systems erstellt(Abb.\ref{fig:Schaltplan}). Fritzing bietet eine sehr große Menge von elektronischen Komponenten und ein PCB\footnote{Printed Circuit Board}, eine Steckplatine und einen Schematic View. In diesem Fall wurde die Breadboard View gewählt, weil dort alles übersichtlicher ist. Was noch gut ist, ist das Fritzing kostenlos in Linux angeboten wird, was für Windows nicht der Fall ist.\cite{Fritzing}
\end{itemize}	
	%	\item MySQL und MariaDB \\
	%	Um die Testdatenbanken zu erstellen und die Benutzerfotos und Benutzerdaten zu speichern, wurde die berühmteste Open-Source relationales Datenbank System, MySQL verwendet. Zusammen mit MySQL wurde auch die Pakete MariaDB auf dem System installiert, damit Python mit MySQL durch einer Schnittstelle verbunden wird. Mithilfe der MariaDB werden die ganzen Tabellen mit Daten gefüllt.
	
	%\item \textit{Planungsmethode} \\
	%\begin{itemize}
	%	\item Structed Software Design \\
	%	Structed Software Design ist die Methode, die zur Planung des Systems verwendet wurde. Diese Software-Architektur ermöglicht den Entwurf, das Implementierungskonzept und das Integrationskonzept des Systems zu planen. Obwohl Structed Design großer Aufwand benötigt, hat diese Methode viele Vorteile, die bei der Wahl der Planungsmethode eine große Rolle gespielt haben: Structed Design verwendet Logik, ist von allem verstehbar, beschreibt alles ohne Abgrenzungen und ganz detailliert. Die wichtigsten Elemente die in der Structed Design beschrieben werden sind:
		%
		%	\cite{StructedDesign}
		%\end{itemize}
	%\end{itemize}
	%Mithilfe der Structed Software Design wurden das Big Picture des Systems zusammen mit seine notwendige Iterationen, die mehr an das Gesichtserkennungsteil konzentriert sind, erstellt. (1.Ebene des Gesichtserkennungsteils)
\subsubsection{Lösungsweg- Beschreibung und Erklärung}
Der Lösungsweg für die Umsetzung der Aufgaben der Gesichtserkennung ist streng mit der vorherigen Planung verbunden. Deshalb wurde nicht nur das Big Picture(Große Sicht des Systems von Außen), die in die vorherigen Kapiteln beschrieben wurde, erklärt, sondern auch die Erste Ebene des Gesichtserkennungsteils.


Die erste Ebene sieht man unter Abb.\ref{fig:Erste Ebene}. Sie ist ein detaillierte Version des Big Picture, das sich nur auf den Erkennungsteil konzentriert. Man spricht von einer Iteration, die hier passiert ist.  Folgend wird die Vorgehensweise und der Lösungsweg dieser Aufgabe mit Hilfe der 1.Ebene erklären und beschrieben.\\

\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures diplom_11Ebene.png}
	\caption{Erste Ebene}
	\label{fig:Erste Ebene}
\end{figure}

Die wichtigste Elemente der ersten Ebene sind auf der Abbildung \ref{fig:Erklaerung_Erste_Ebene} erklärt: \\

\begin{figure}[H]
	\includegraphics[width=\textwidth]{\ordnerfigures Erklaerung_Erste_Ebene.png}
	\caption{Erste Ebene Erklärung}
	\label{fig:Erklaerung_Erste_Ebene}
\end{figure}

\textbf{Einzelne Arbeitsschritte des Erkennungsprozesses: }\\

In diesem Unterkapitel wird der Vergleich der Gesichter der Personen detailliert erklärt. Es wurden die einzelne Schritte der Arbeit sowie die verwendeten Methoden beschrieben.

\begin{enumerate}
	
	\item \textit{Erkennungstaster wird gedr{\"u}ckt} \\
	
	Will der Benutzer sich im System einloggen, muss er zuerst den Erkennungstaster dr{\"u}cken. Wird dieser Taster gedr{\"u}ckt, dann kriegt der Benutzer eine Anmeldung, bei der er seine Emailadresse eingeben muss. Um diese Aufgabe zu erledigen, muss das Paket RPi.GPIO importiert werden. Auf diese Weise ist der Zugriff auf den GPIO Pins m{\"o}glich, damit der Taster Zustand, oder der LED Zustand erkannt werden. Das Paket mysqldb wird auch ben{\"o}tigt, um Zugriff auf die Datenbank zu haben. Der untere Codeabschnitt \ref{fig:Integration des Tasters} zeigt wie das programmiert wird: 
	\begin{lstlisting}[caption={Integration des Tasters}, label={fig:Integration des Tasters}, language=Python]
	if GPIO.input(17):
	exec(open('Existiert_nExistiert.py').read()) 
	\end{lstlisting} 
%-----------------------------------------------------
	\item \textit{Benutzer gibt seine Emailadresse ein} \\
	
Es ist wichtig zu erw{\"a}hnen, dass es für die Umsetzung dieses Systems notwendig ist, die verschiedenen Skripte miteinander zu verbinden.  Deshalb müssen sie innerhalb anderer Skripte aufgerufen werden. Das wird durch Variablen gemacht. Deshalb ist das Importieren der Pakete \textit{sys} und \textit{os} n{\"o}tig. Der Benutzer gibt seine Emailadresse an, die danach verwendet wird, um in der Datenbank schneller auf die Benutzerbilddaten zuzugreifen. Es wurde deshalb die Emailadresse(und nicht Vorname, Nachname usw.) gewählt, weil diese Adresse immer eindeutig ist, das heißt, es ist unmöglich, dass zwei Benutzern dieselbe Adresse haben, und dasselbe kann für die andere Benutzerdaten(Vorname, Nachname usw.) nicht gesagt werden. Der untere Codeabschnitt \ref{fig:kot} zeigt wie das programmiert wird: 

%-----------------------------------------------------
	\item \textit{Die Existenz der eingegebenen Emailadresse des Benutzers in der Datenbank wird geprüft} \\

  \begin{lstlisting}[caption={{\"U}berpr{\"u}fung der Existenz der Emailadresse}, label={fig:kot}, language=Python]
  for x in myresult:
  if x[2]==rei.emailiperkrahasim:
  bool=True
  else:
  bool=False
  os.system('./Log_Erkennung_Email_Nicht_Gefunden.py')
\end{lstlisting}

Wie es vorher erwähnt wurde, ist dieser Schritt deswegen wichtig, weil falls die eingegebene Email nicht in der Datenbank existiert, muss das System den Bildvergleich nicht machen. Der Benutzer kriegt stattdessen eine Anmeldung, die ihm sagt, dass er noch einmal versuchen kann seine Emailadresse einzugeben. Wird diese neue Adresse auch nicht in der Datenbank gefunden, kann danach dieser Benutzer mit dieser Adresse sich nicht mehr versuchen sich beim System anzumelden. 
%-----------------------------------------------------
\item \textit{Bild wird gemacht und tempor{\"a}r gespeichert} \\

Gleich nachdem der Benutzer sein Email eingegeben hat, macht die Kamera das Bild. Dieses Bild wird tempor{\"a}r gespeichert, weil es nach dem Vergleich mit dem Bild, das schon in der Datenbank liegt, nicht mehr benötigt wird. Sonst w{\"u}rde es extrem viele Bilddaten in der Datenbank geben, die nur einmal verwendet werden. Stattdessen wird nur der Pfad des Bildes zusammen mit den extrahierten Punkten in der Datenbank gespeichert.
%-----------------------------------------------------
	\item \textit{Gemachtes Bild wird zugeschnitten} \\
	
Das von der Kamera gemachtes Bild ist noch nicht bereit zum Vergleich. Um die Punkte richtige zu extrahieren, muss das Bild zuerst zugeschnitten werden. Das heißt, die Dimensionen des Bildes werden reduziert, und somit werden die andere Objekten auf dem Bild nicht berücksichtigt(Sie würden die Performance der Vergleichsprozess negativ beeinflussen). Das Zuschneiden des Bildes wurde mit Hilfe eines Programms, das Teil der Arbeit der Bildverarbeitungsgruppe ist, gemacht. Wird das Bild zugeschnitten, wird es automatisch auch umbenannt. Das Bild nimmt das Schlüsselwort „New“+die Emailadresse der Person als Name. Der Datentyp ist .jpg .
%-----------------------------------------------------
	\item \textit{Die Gesichtspunkte werden extrahiert} \\
	
Das zugeschnittene Bild des Gesichts der Person besteht aus verschiedene Punkte. Insgesamt sind es 68 Gesichtspunkte. Alle diese Punkte müssen für den Vergleichsprozess extrahiert werden. Das heißt, jeder Punkt muss ein X und ein Y Wert haben. Diese Koordinaten müssen ermittelt werden. Dies ist auch eine Aufgabe der Bildverarbeitungsbranche, und ist extrem wesentlich für das Funktionieren des Erkennungsprozesses.
%-----------------------------------------------------
	\item \textit{Wird dieselbe Emailadresse in der Datenbank gefunden, werden die zugehörige Bildinformationen geladen} \\
	
	Falls aber die vom Benutzer eingegebene Emailadresse schon in der Datenbank liegt, weißt das System Bescheid, dass ein Bilderdatenvergleich stattfinden muss. Um das zu erreichen, werden alle Bildinformationen geladen. Unter Bildinformationen sind die 68 extrahierten Gesichtspunkte zu verstehen. Der kurze Codeabschnitt \ref{fig:Bildinformationen werden selektiert, wenn Email gefunden wird} unten zeigt genau wie dies funktioniert: \\
	
  \begin{lstlisting}[caption={Bildinformationen werden selektiert, wenn Email gefunden wird}, label={fig:Bildinformationen werden selektiert, wenn Email gefunden wird}, language=Python]
  if b=="existiert":
  mycursor.execute(
  """select * from info i \
  join person p \
  on i.idP=p.idP \
  where p.email='%s';"""%var1)
  myresult=mycursor.fetchall()
  for x in myresult:
  print(x)
  \end{lstlisting}
	
	Das heißt, die extrahierte Punkte des von der Kamera gemachten Bildes und die extrahierte Punkte, die in der Datenbank gespeichert sind und die den Person mit derselbe Emailadresse wie die vom Benutzer eingegebene Adresse gehören , stehen jetzt endlich zur Verfügung. Ab hier wird angenommen, dass die eingegebene Emailadresse mit mindestens einer in der Datenbank vorhandenen Emailadresse gleich ist, damit der Vergleichsprozess erklärt werden kann.
%-----------------------------------------------------
	\item \textit{Die extrahierten Punkte werden in 5 verschiedene Bereiche geteilt} \\
	
	Bevor der Vergleichsprozess beginnt, müssen die 68 extrahierten Punkte geteilt werden. Die 5 großen Bereiche sind das Gesicht, die Nase, das rechte Auge, das linke Auge und der Mund. Jeder Bereich hat seine eigenen Punkte. Die erste 28 Punkte gehören dem Gesicht, die nächste 9 gehören der Nase, die nächste 6 dem rechten Auge, die nächste 6 dem linken Auge und die letzte 19 gehören dem Mund. Durch dieser Prozess wird die Vergleichsqualität stark erhöht, weil die Punkte der Nase werden genau mit der Punkte der anderen Nase verglichen, und nicht mit dem von dem Augen beispielsweise. \\
	Der untere Codeabschnitt \ref{fig:Teilung der extrahierten Punkte in 5 Bereiche} zeigt wie dieser Schritt für die ersten 27 Punkte programmiert wird(nur um eine Idee zu haben, wie es funktioniert):\\

  \begin{lstlisting}[caption={Teilung der extrahierten Punkte in 5 Bereiche}, label={fig:Teilung der extrahierten Punkte in 5 Bereiche}, language=Python]
  for pika in range(0,27):
  dis=math.sqrt(abs(( (vleratx.item(pika)
  -float(res[vx]))))* 
  abs( (vleratx.item(pika)-float(res[vx])) ) + ( 
  abs((vleraty.item(pika)-float(res[vy])))*
  abs((vleraty.item(pika)-float(res[vy])) ) ))
\end{lstlisting}

%-----------------------------------------------------
	\item \textit{Die Bildinformationen der beiden Bilder werden verglichen} \\
	
Die wichtigste Aufgabe ist der Vergleich der Bildinformationen. Es werden die extrahierten Gesichtspunkte der bereits gemachten Bilder mit der Gesichtspunkte in der Datenbank verglichen. Selbstverständlich müssen, wie es vorher erwähnt wurde, die beiden Personen, deren Gesichtspunkte verglichen werden dieselbe Emailadresse haben. Das wichtigste Paket, Open CV, wird für diesen Vergleich ben{\"o}tigt. Nachdem dieses Paket importiert wurde, kann der Vergleich beginnen. Es gibt verschiedene Schritte, die erfolgen, und die nun erklärt werden:
\begin{itemize}
	\item Startpunkt bzw. Origin wird festgelegt \\
	
	In jeden Gesichtsbild wird ein Startpunkt bzw. eine Origin für den Vergleich festgelegt. Dieser Punkt ist der Punkt mit der Koordinaten (0/0). Es wird der Abstand von jedem anderen Gesichtspunkt zu dieser Origin berechnet. Dieser Abstand wird dann mit dem entsprechenden Abstand des zweiten Bildes verglichen. Diese Abstände müssen miteinander übereinstimmen(zum Beispiel ein Punkt vom rechten Augen im ersten Bild muss mit dem zugehörigen Punkt im zweiten Bild verglichen werden, und nicht mit einem Punkt von dem Augen in ersten Bild).
	\item Die Abstände jedes anderen Punktes des gemachten Bildes vom Startpunkt werden berechnet. \\
	Nachdem der Startpunkt festgelegt wurde, beginnt der Vergleich der Abstände des gemachten Bildes(Punkt-Startpunkt) und der Abstände, die in der Datenbank gespeichert sind.
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\textwidth]{\ordnerfigures Vergleichsweg.png}
		\caption{Vergleichsmethode zweier Punkte}
		\label{fig:Vergleichsweg}
	\end{figure}
	
	Auf Abbildung \ref{fig:Vergleichsweg} wird die verwendete Vergleichsmethode dargestellt. Der Startpunkt hat die Koordinaten (0/0) und befindet sich links oben. Jeder Punkt hat seine bestimmten Koordinaten, zum Beispiel, der Punkt 36 des ersten Bildes hat die Koordinaten x1 und y1, und den 36.Punkt des anderen Bildes hat die Koordinaten x2 und y2. Um den Abstand des Punkt 36 zu berechnen, wird die pythagoreische Formel verwendet. Die Differenz der x-Koordinaten und die Differenz der beiden y-Koordinaten sind die beide Katheten(a und b auf der Abbildung). Um die Hypotenuse zu finden wird das Quadrat beider Katheten addiert, und am Ende wird die Wurzel des Ergebnisses berechnet. Das Ergebnis ist der Abstand des Punktes 36 vom Startpunkt. Dieselbe Methode wird für jeder Punkt verwendet.
	Das obige Beispiel vergleicht die Abstände der Punkte von 2 verschiedenen Bildern. Das Vergleichsprinzip ist dasselbe wie bei dem Vergleich der Punkteabstände des gemachten Bildes und der in der Datenbank gespeicherten Punkteabstände. Es ist einfach leichter erklärbar und verstehbar, wenn 2 Bildern verglichen werden. 
	Die Abstände aller Punkt aller Bereiche werden in einer Variable gespeichert.\\
	
	\item Es wird der maximale Abstand für jeden einzelnen Bereich berechnet \\
	
	Nachdem die oben erklärten Abstände kalkuliert wurden, wird der maximale Abstand für jeden Bereich(Gesicht, Nase, linke Auge, rechte Auge, Mund) benötigt. Diese Maximumwerte sind wesentlich für den Vergleich. Warum das so ist wird später erklärt. \\
	Der untere Codeabschnitt \ref{fig:max} zeigt wie dieser Schritt für die ersten 27 Punkte implementiert ist: \\
	
\begin{lstlisting}[caption={Berechnung der Maximumwerte}, label={fig:max},language=Python]
  MAX = [0,0,0,0,0]
  for pika in range(0,27):
  dis=math.sqrt(abs(( (vleratx.item(pika)
  -float(res[vx]))))* 
  abs((vleratx.item(pika)-float(res[vx])) ) + ( 
  abs((vleraty.item(pika)-float(res[vy])))* 
  abs((vleraty.item(pika)-float(res[vy])) ) ))
  if(dis < min):
	 min = dis
  if(dis > max):
	 max = dis    
  global MAX
  MAX[0]=max
  print("Max:\%s\n"\%(MAX[0]))
  min=10.0
  max=0.0
  dis=0
\end{lstlisting}
	
	Zuerst wurde eine Array MAX erstellt, das 5 Elemente enthält. Jedes Element gehört zu einem der 5 Bereiche. Beispielsweise der Maximumwert an der Stelle 0(erste Element) ist der Maximumabstand, der bei dem Gesichtsbereich gefunden wurde. Die Funktion Max in Python, die den größte Wert automatisch findet, wurde verwendet. Jeder Abstand wird mit dem Maximumwert verglichen(Maxwert beginnt am Anfang bei 0). Ist er größer, dann wird dieser Abstand der neue Maximumwert. So wird der Maximumwert ermittelt.
	
	\item Es wird das geometrische Mittel der Abstände aller Bereiche berechnet \\
	
	"Das geometrische Mittel der Abstände aller Punkte (nicht in einzelnen Bereichen) ist auch wichtig für den Vergleich. Es gibt 68 Gesichtspunkten insgesamt, das heißt, 68 Abstände von dem Startpunkt. 
	Um das geometrische Mittel von n Zahlen x1,x2,…xn zu ermitteln, muss man deren Produkt bilden und von diesem die n-te Wurzel ziehen."\cite{geometrischesM}\\
	
	Auf Abbildung \ref{fig:geometrischesM} wird die Formel, die sich ergibt gezeigt:
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\textwidth]{\ordnerfigures geometrischesM.png}
		\caption{geometrisches Mittel}
		\label{fig:geometrischesM}
	\end{figure}

	Der untere Codeabschnitt \ref{fig:gm} zeigt wie dieser Schritt für die ersten 27 Punkte implementiert ist(nur um eine Idee zu haben, wie es funktioniert):

\begin{lstlisting}[caption={Berechnung des geometrischen Mittels f{\"u}r die erste 27 Punkte}, label={fig:gm},language=Python]
  for pika in range(0,27):
   dis=math.sqrt(abs(( (vleratx.item(pika)
   -float(res[vx]))))* abs( 
   (vleratx.item(pika)-float(res[vx])) ) + ( 
   abs((vleraty.item(pika)-float(res[vy])))* 
   abs((vleraty.item(pika)-float(res[vy])) ) ))
  gm *= dis
  vx+=2
  vy+=2
  gm=gm**(1/27)    
  print("GM:%s\n"%(gm))
  gm=1
  dis=0
\end{lstlisting}
	\item Die ermittelte Maximumwerte und die geometrischen Mittel der Abstände der Punkte des gemachten Bildes werden mit der Maximumwerten und den geometrische Mitteln der Abstände der, in der Datenbank, gespeicherten Punkte verglichen \\
	
	\begin{enumerate}
		\item Beschreibung \\
		
		Wenn die angesprochene Maximumwerte und die geometrische Mittel der Abstände der Punkte des gemachten Bildes und die geometrische Mittel der Abstände der in der Datenbank gespeicherten Punkte gleich oder sehr ähnlich sind, dann wird von der selben Person gesprochen und die Erkennung ist erfolgreich. Deshalb werden einige Abgrenzungen bestimmt, wann die Erkennung als erfolgreich gilt und wann nicht.
		
		\item Mögliche Fälle \\
		
		Insgesamt gibt es 5 Bedingungen bzw. 5 Fälle, die eintreten können und die wichtig sind. Diese Bedingungen wurden mit Hilfe vieler gemachten Tests, über die später gesprochen wird, bestimmt. Ist einer dieser fünf Bedingungen wahr, ist die Erkennung nicht erfolgreich und es wird nicht von derselben Person gesprochen. Diese Fälle werden unten mit Hilfe von Bildern erklärt. Es werden die Maximumwerten jedes Bereichs(Gesicht, Nase, linke Auge, rechte Auge, Mund, also 5 insgesamt), sowie das geometrische Mittel aller 68 Punkten berücksichtigt.
		
		\begin{enumerate}
			\item 1.Fall: Mindestens 2 Maximumwerte sind größer als 0.06 \\
			
				\begin{figure}[H]
				\centering
				\includegraphics[width=0.7\textwidth]{\ordnerfigures 1_Fall.png}
				\caption{1\_Fall}
				\label{fig:1_Fall}
			\end{figure}
			
			Sind 2 oder mehrere Maximumwerte größer als 0.06, wird das geometrische Mittel betrachtet. Ist der Wert größer als 0.01, gibt es keine Übereinstimmung. Wenn weniger als 2 Werte größer als 0.06 sind, muss auch das geometrische Mittel kleiner als 0.027 sein, um eine erfolgreiche Erkennung zu haben. \\
			
			Auf Abbildung \ref{fig:1_Fall} ist ein Flussdiagramm dargestellt, das die Abfolge dieser Bedingung beschreibt.\\
			
		Der Codeabschnitt \ref{fig:1}, der zeigt wie das funktioniert:\\
			
\begin{lstlisting}[caption={1.Fall},label={fig:1}, language=Python]
  global count
  count = 0
  for i in range(0,len(MAX)):
   if MAX[i] > 0.06:
   count+=1
   status1=True
   status11=True
   status2=True
   status22=True
				
#Wenn JA: Nur wenn gmT kleiner als 0.01 
sind sie richtig, sonst FALSCH

  if count ==1:
   global status11
   status11=False
  if count >= 2:
   global status22
   status22=False
  if gmT > 0.01:
   global status1
   status1 = False
				
#Wenn NEIN: gmT muss kleiner als 0.027 sein,
			um RICHTIG zu sein
  else:
   if gmT > 0.027:
   global status2
   status2 = False
\end{lstlisting}
	
			
			\item 2.Fall: Genau einen Maximumwert größer als 0.07 ist und kleiner als 0.084 \\
			
				\begin{figure}[H]
				\centering
				\includegraphics[width=0.7\textwidth]{\ordnerfigures 2_Fall.png}
				\caption{2\_Fall}
				\label{fig:2_Fall}
			\end{figure}
			
			Stimmt dieser Bedienung, wird wieder überprüft, ob das geometrische Mittel kleiner als 0.027 ist oder nicht. Wenn ja, dann gibt es keine Übereinstimmung. Ist aber dieser Bedienung wahr für mehr als einen Wert, gibt es keine Übereinstimmung. \\
			
			Auf Abbildung \ref{fig:2_Fall} ist ein Flussdiagramm dargestellt, das die Abfolge dieser Bedingung beschreibt.\\
			
	Der Codeabschnitt \ref{fig:2}, der zeigt wie das funktioniert:\\
		
		\begin{lstlisting}[caption={2.Fall},label={fig:2}, language=Python]
  count = 0
  for i in range(0,len(MAX)):
   if MAX[i] > 0.07 and MAX[i]< 0.084:
    count+=1
    status3=True
    status33=True
    status4=True
    
#Wenn JA :Wenn gmT kleiner als 0.027 ist passt, 
sonst FALSCH

  if count == 1:
   global status33
   status33=False
  if gmT > 0.027:
   global status3
   status3 = False
   
#Wenn 2 oder mehr: FALSCH

  elif count > 1:
   global status4
   status4 = False
\end{lstlisting}
			
			\item 3.Fall: Mindestens einen Maximumwert ist größer als 0.084 \\
			
				\begin{figure}[H]
				\centering
				\includegraphics[width=0.7\textwidth]{\ordnerfigures 3_Fall.png}
				\caption{3\_Fall}
				\label{fig:3_Fall}
			\end{figure}
			
			Trifft dieser Bedienung zu, stimmt die Erkennung nicht und der Person wird nicht vom System erkannt.\\
			
			Auf Abbildung \ref{fig:3_Fall} ist ein Flussdiagramm dargestellt, das die Abfolge dieser Bedingung beschreibt.\\
			
		Der Codeabschnitt \ref{fig:3}, der zeigt wie das funktioniert:\\
		
		\begin{lstlisting}[caption={3.Fall},label={fig:3}, language=Python]
  for i in range(0,len(MAX)):
   if MAX[i] > 0.084:
    count+=1
    status5=True
    
#Wenn JA: FALSCH

  if count >=1:
   global status5
   status5=False
\end{lstlisting}
			
		\end{enumerate} 
	
		\item Andere Abgrenzungen und Entscheidungen \\
		
		Trifft eine von diesen 2 unterstehenden Kombinationen zu, ist weitere Überprüfung (geometrisches Mittel) nicht mehr nötig und es gibt keine Übereinstimmung.
		\begin{enumerate}
			\item Ein Maximumwert größer als 0.06 und ein Maximumwert größer als 0.07 \\
			\item Zwei Maximumwerte größer als 0.06 und ein Maximumwert größer als 0.07 \\
		\end{enumerate}
	
		Der Codeabschnitt \ref{fig:4}, der zeigt wie das funktioniert:\\
		
\begin{lstlisting}[caption={Andere Abgrenzungen und Entscheidungen},label={fig:4}, language=Python]
if status1==False or status2==False 
or status3==False or status4==False 
or status5==False or
(status11==False and status33==False) 
or (status22==False and status33==False):
print("Problem!!!")
os.system
('./Log_Erkennung_Person_Existiert_Nicht.py')
\end{lstlisting}
		
	\end{enumerate}
%----------------------------------------------------
\item \textit{Ist die Erkennung erfolgreich, kriegt der Benutzer eine Information, dass er im System erfolgreich angemeldet ist.} \\

Wenn keinen Fall bzw. Bedienung zutrifft, ist die Authentifizierung erfolgreich. Der Benutzer kriegt danach eine Information, die ihm Bescheid gibt, dass die Authentifizierung erfolgreich war und dass er weitermachen darf. Dazu wurde eine gelbe LED verwendet, die leuchtet. \\	

Der Codeabschnitt \ref{fig:5}, der zeigt wie das funktioniert:\\

\begin{lstlisting}[caption={Erkennung ist erfolgreich},label={fig:5}, language=Python]
else:
b="existiert"
print("Eingeloggt!!!")
os.system('./Log_Erkennung_Person_Existiert.py')
\end{lstlisting}

\end{itemize}
\end{enumerate}
\subsubsection{Andere wichtige Punkte und Abgrenzungen}

Es gibt auch einige Punkte, die erwähnt werden müssen, und die zur Verwendung des Systems wesentlich sind:

\begin{enumerate}
	\item Distanz der Benutzer von der Kamera \\
	
	Damit der Vergleich und die Erkennung der Gesichter erfolgreich und so genau wie möglich ist, gibt es eine Distanz, die der Benutzer von der Kamera stehen muss. Diese Distanz ist 1 Meter, dem Benutzer wird das durch einer Linie auf dem Boden angezeigt.
	\item Unbekannte Emailadresse eingegeben \\
	
	Wenn der Benutzer nach dem Drücken des Tasters eine falsche Emailadresse eingibt, wird er informiert, dass er eine zweite Chance bekommen wird, die richtige Emailadresse einzugeben(Vielleicht hat er zum Beispiel ein Fehler beim Eintippen gemacht). Ist die Adresse noch immer unbekannt oder inkorrekt, beginnt der Vergleichsprozess nicht und der Benutzer kann sich nicht anmelden.
	
	\item Kein eindeutiges Gesicht von der Kamera nach der Bildaufnahme gefunden \\
	
	Wenn nach der Bildaufnahme kein eindeutiges Gesicht erkannt wird, wird ein zweites Bild gemacht. Der Benutzer wird durch eine Meldung erinnert, dass er gerade und an der Linie stehen muss.
	
	\item Mehrere Gesichter von der Kamera nach der Bildaufnahme gefunden \\
	
	Wenn nach der Bildaufnahme mehrere Gesichter erkannt werden, wird wieder ein zweites Bild gemacht. Werden wieder mehrere Gesichter erkannt, kann das System nicht überprüfen, ob sich der Benutzer anmelden darf oder nicht (Nicht Ziel).
	
	\item Benutzer vom System nicht erkannt \\
	
	Ist die Authentifizierung nicht erfolgreich, leuchtet eine rote LED um den Benutzer zu zeigen, dass er sich nicht anmelden darf. Er kann aber alles nochmals probieren(Erkennungstaster drücken usw. …), oder er kann sich registrieren.
	\item Verarbeitungszeit des Systems \\
	
	Jedes intelligente System braucht einer Verarbeitungszeit. Der Erkennungsprozess braucht ungefähr 7 bis 8 Sekunden. Das ist aber auch von der Geschwindigkeit des Benutzers abhängig.
\end{enumerate}
\subsubsection{Das Testen}
Eine der wichtigsten Arbeitspakete des Erkennungsteils war das Testen des Vergleichsverfahrens. Um die Vergleichsbedingungen und Begrenzungen, die weiter oben erwähnt wurden, zu finden und zu bestimmen, war es wesentlich und extrem notwendig, viele Tests zu machen. Zuerst hat der Prozess des Testens mit verschiedene Bilder einer Person begonnen. Danach wurden Bilder verschiedener Personen verwendet, um eine Toleranz zu finden, die in der Bedienungen verwendet werden kann. Nachdem die Gesichtspunkte von zwei Bildern getestet und verglichen waren, sind die Ergebnisse auch mit den in der Datenbank gespeicherten Punkten getestet worden. Am Ende des Testens sind die vorher erklärte Bedingungen definiert und formuliert worden.\\

\subsubsection{Das Logging}
Jedes große System braucht Logging. Mit Hilfe einer Logdatei (englisch: log file) können alle oder bestimmte Aktionen von Prozessen auf einem Computersystem automatisch protokolliert werden. Das heißt, diese Logdatei kann vom Benutzer verwendet werden, um Fehlermeldungen zu erhalten, um den Fehler zu verstehen, um den Zeitpunkt verschiedener wichtiger Ereignissen zu erfahren und vieles mehr. Alle diese Vorteile und Merkmale des Logging waren mehr als genug zum entscheiden, dass die Protokollierung der Ereignisse des Systems ein wichtiges Ziel sind. Das war der Grund, warum der Gesichtserkennungsteil auch protokolliert.\\
Es wurden die wichtigsten Ereignisse mitprotokolliert:
\begin{enumerate}
	\item Der Zeitpunkt, wann der Erkennungstaster gedrückt wurde \\
	
	Es ist sehr wichtig für die Admins des Systems zu wissen, wann der Erkennungstaster gedrückt wurde, bzw. wann die Gesichtserkennungsprozess beginnt. Diese Zeit kann dafür verwendet werden, um die totales Dauer des Erkennungsprozesses zu bestimmen.
	
	\item Der Zeitpunkt, wann der Benutzer erfolgreich angemeldet war \\
	
	Dieses Ereignis ist ein sehr wichtiges, weil es der Schlusspunkt des Erkennungsteils ist. Es kann auch als Beweis verwendet werden, dass der Benutzer im System schon registriert war.
	
	\item Der Zeitpunkt, wann der Benutzer sich nicht erfolgreich anmeldet \\
	
	Wie vorher erwähnt, ist eine Log-Datei eine sehr gute Methode, wichtige Fehlermeldungen sehr schnell zu erhalten. In diesem Fall wird gespeichert, wann der Benutzer sich nicht erfolgreich anmeldet.
	
	\item Der Zeitpunkt, wann die eingegebene Emailadresse in der Datenbank nicht gefunden wird \\
	
	Gibt der Benutzer eine falsche oder eine nicht existierende Emailadresse ein, wird dieses Ereignis geloggt. Das ist extrem wichtig für die Administratoren, weil ohne eine vom Benutzer eingegebene Emailadresse, die in der Datenbank schon existiert, beginnt die Vergleichsprozess für die Erkennung gar nicht. Auf diesem Weg wissen die Administratoren, wo der Fehler ist, und der Benutzer wird darüber informiert.
\end{enumerate}
\textbf{Wie wurde das Logging gemacht?}\\
Das Logging des Gesichtserkennungsprozesses war nicht sehr komplex in Python. Es gab eine Tabelle in der Datenbank, die für dieser Funktion geeignet war. In dieser Tabelle wurden alle Informationen, die protokolliert werden müssen, gespeichert. Mit Hilfe einer Python Skript wurde dann die Verbindung aller Skripte, die die notwendige Informationen senden mit dieser Log Tabelle, die in der Datenbank liegt, gemacht. Es wurde danach ein Programm für jeder Ereignis, das oben erwähnt war, erzeugt. Diese Programme ermöglichten die Verbindung mit der Datenbank, und zeigten eine Anmeldung. Beispielweise wurde in der Datenbank notiert, dass es ein Problem bei der Gesichtserkennung gab(Taster nicht gedrückt..). In den Hauptskript wurde dann dieses einzelne Programm aufgerufen.

Die Codeabschnitte \ref{fig:L1} und \ref{L2, } zeigen, wie das programmiert wurde:\\

Der Taster wird gedrückt: \\

\begin{lstlisting}[caption={Log f{\"u}r gedr{\"u}cktes Taster},label={fig:L1},language=Python]
	if GPIO.input(17):
	os.system('./Log_Erkennung_TasterGed.py')
\end{lstlisting}

Zeitpunkt wird gespeichert: \\

\begin{lstlisting}[caption={Log f{\"u}r den Zeitpunkt},label={fig:L2},language=Python]
logging.basicConfig(filename=log_file_path)
if(log_to_db):
logging.getLogger('').addHandler(logdb)
log=logging.getLogger('Gesichtserkennung')
log.setLevel(log_error_level)
test_var='Taster gedruckt'
log.error('This event occurred: %s' % test_var)
\end{lstlisting}

	\section{Herausforderungen, Probleme, und deren Lösung}
	W{\"a}hrend dieser Arbeit musste man einigen Problemen und Herausforderungen lösen.
	\begin{itemize}
		\item \textit{OpenCV Installation}\\
		
		Die gr{\"o}ßten Probleme hat es bei der Installation von OpenCV gegeben. Diese Installation hat sehr lang gedauert und es war sehr schwer zu bestimmen, welche Paketen ausgelassen werden sollten und welche nicht. Dieses Problem wurde nach vielen Tests gel{\"o}st, durch das Kopieren von einer anderen SD-Karte, auf der OpenCV bereits installiert war. CMake und Make waren sehr wichtige Pakete, mit denen diese Aufgabe erledigt wurde.
		\item \textit{Fritzing} \\
		
		Das Problem beim Fritzing war, dass jedes Mal wenn das Programm beendet wurde, es nicht mehr ge{\"o}ffnet werden konnte. Es fehlten entweder die Pfaden oder die Bauteile, die f{\"u}r  die Schaltung notwendig waren. Die L{\"o}sung war eigentlich sehr leicht. Das Programm wurde komplett gel{\"o}scht und dann wieder im System installiert, und danach wurde die ganze Schaltung gemacht, ohne das Programm zu beenden. Sonst wären dieselben Probleme wieder aufgetreten.
		\item \textit{Kurzschluss beim Raspberry Pi}\\
		
		Was noch passiert ist, ist das es beim Anfassen vom Raspberry PI einen Kurzschluss gab. Der Raspberry PI war kaputt und musste ersetzt werden. Glücklicherweise konnte die SD-Karte erfolgreich kopiert werden und deshalb sind alle Daten und Informationen gespeichert.
		
		\item \textit{Paket FaceRecognition Installation} \\
		
		Die Installation des Paketes FaceRecognition konnte nicht erfolgreich gemacht werden, weil die dlib Pakete auch gebraucht wurden. Wahrscheinlich aufgrund des zu geringen RAMs kann man diese Pakete nicht installieren. Dieses Problem wurde noch nicht gel{\"o}st.
		
		\item \textit{Probleme bei der Aufruf der Skripten } \\
		
		Am Beginn war das Umgehen mit dem Aufruf der Skripten sehr schwer. Es war schwer zu verstehen wie das genau funktioniert, weil die große Variablenanzahl die Arbeit kompliziert machte. Dieser Anzahl wurde reduziert und es wurden viele Recherchen über die korrekten Verwendung des \textit{sys} Paketes gemacht um das Problem zu l{\"o}sen.
		
		\item Schlechtere Vergleichsqualität \\
		
		Am Beginn des Testens des Vergleichs waren die Ergebnisse nicht stabil. Es konnte keinen Zusammenhang gefunden werden. Beispielsweise waren die Maximumwerte der Abstände bei Bilder, die derselben Person gehörten größer als bei Bildern, die verschiedenen Personen gehörten. Nach viele Tests wurde der Grund verstanden. Die 68 Punkte mussten in 5 verschiedene Teile(Gesicht, Nase, linke Auge, rechte Auge, Mund) zerlegt werden. In dieser Weise wird ein Punkt, der dem Mund gehört nicht mit einem Punkt, der der Nase gehört verglichen.
		
		\item Probleme bei Einteilung der Gesichtspunkte in 5 Bereichen \\
		
		Der Prozess der Einteilung der Gesichtspunkte in dem verschiedenen Bereiche war auch schwierig. Ein großes Array mit 68 Elementen wurde verwendet. Es war sehr kompliziert auf einem Index dieses Array zu zugreifen. Deshalb wurde dieses große Array in 5 kleinere Arrays zerlegt. Auf diese Weise war es viel leichter zu verstehen, wie die Indizien funktionieren und wie man dort zugreifen kann.
		
		\item Probleme bei der Berechnung des geometrischen Mittels \\
		
		Die Berechnung des geometrischen Mittels war auch nicht leicht. Nachdem die Formel gefunden war, musste es in dem Programm integriert werden. Die Schwierigkeit war bei dem Ziehen von der N-Wurzel. Sollte das n 67 oder 68 sein? Das war von dem Index abhängig. Am Ende wurde verstanden, dass das Produkt aller Abstände hoch 1/68, die richtige Lösung ist.
		
		\item Probleme mit der Datenbank \\
		
		Probleme hat es noch beim Zugriff auf der in der Datenbank gespeicherten Gesichtspunkte gegeben. Es war sehr kompliziert zu verstehen, wie und wo  die Punkte genau gespeichert waren(Auf welchem Index die X-Werte, auf welchem die Y-Werte). Es wurde deshalb Hilfe von dem Mitarbeiter, der sich mit der Datenbank beschäftigt hat, gebraucht, und danach war alles klarer und verständlich.
		
		\item Probleme mit GIT \\
		
		Am Ende müssen die Probleme mit Git erwähnt werden. Es gab viele Fälle, wo es Konflikten mit den Dateien gab. Man muss immer zuerst Pull machen, und danach Push. Das ist aber oft nicht passiert. Es wurde in einer Datei gearbeitet, die aber von einem anderen Person schon geändert wurde. Deshalb gab es Probleme bei dem Push. Oft mussten die ganze Dateien gelöscht werden, und danach wieder vom Git geholt werden. Es wurde am Ende in der Gruppe darüber gesprochen und das Problem gelöst.
	\end{itemize}

	\section{Projektmanagement und Controlling}
	In Bezug auf Projektmanagement und Controlling wurde die Methode des Fehlerbaums verwendet. Diese ist eine ber{\"u}hmte Methode um die Aufwandsch{\"a}tzung zu berechnen und um eine Fehlerursache zu finden. Das Problem wird in kleinen Teile geschnitten damit es klarer wird. 
	\begin{figure}		
		\includegraphics[width=\textwidth]{\ordnerfigures Fehlerbaum.png}
		\caption{Fehlerbaum}
		\label{fig:Fehlerbaum}
	\end{figure}
	Es wurde eine detaillierte Soll-Ist Analyse gemacht, die bei der neuen Aufgabeteilung und eine Fehlerbaumanalyse zu erstellen sehr geholfen hat.\\
	
	Die Fehlerbaumanalyse wird verwendet, um die Zuverlässigkeit von technischen Systemen zu testen. Die Fehlerbaumanalyse nimmt als Ausgangspunkt nicht eine einzelne Systemkomponente, sondern das potenziell gestörte Gesamtsystem. Die Fehlerbaumanalyse baut auf der sogenannten negativen Logik auf. Das heißt, der Fehlerbaum beschreibt eine Ausfallsfunktion die bei dem Zustand logisch-1 einen Ausfall ausdrückt, bei logisch-0 liegt ein funktionsfähiges System vor.
	Sie gehört zu den ``Top-Down''- Analyseformen im Risikomanagement. In einem ersten Schritt wird daher das Gesamtsystem detailliert und exakt beschrieben. Darauf aufbauend wird analysiert, welche primären Störungen eine Störung des Gesamtsystems verursachen oder dazu beitragen können. Ausgangspunkt ist hierbei zunächst ein einziges unerwünschtes Ereignis, welches an der Spitze des Fehlerbaums steht, das sogenannte Top-Ereignis. Das Top-Ereignis resultiert in der Regel aus einer Risikoanalyse bzw. Szenarioanalyse.
	In der einfachsten Form besteht er aus folgenden Elementen: Entscheidungsknoten (E), die Entscheidungen kennzeichnen, Zufallsknoten, die den Eintritt eines zufälligen Ereignisses darstellen sowie aus Ergebnisknoten (R), die das Ergebnis von Entscheidungen oder Ereignissen darstellen.
	
	Auf der Abbildung \ref{fig:Fehlerbaum} wird ein Fehler in den Gesichtserkennungsteil des Systems beschrieben. Zuerst muss überprüft werden, ob der Fehlern bei der Hardware oder Software liegt.\\
	
	\textit{Hardware Problem}\\
	Ist es ein Problem in Hardware, wird der Raspberry Pi und die Steckboard getestet. Beim Raspberry kann es entweder Probleme mit dem SD-Karte oder mit der GPIO Pins geben. Bei dem Steckboard sind entweder die Kabel und die Verbindungen falsch eingesteckt, oder die Bauteile sind kaputt(Taster, Widerstand, LED, Kamera).\\
	
	\textit{Software Problem}\\
	Wenn es ein Softwareproblem ist, sind entweder die Versionen vermischt(Problem mit GIT), oder es gibt Programmierfehlern. Diese Programmierfehlern können bei der Logik(Algorithmen) oder bei der Syntax auftreten(Skripten Aufruf, Variablen usw.)
	
	\section{Ergebnisse}
	Die finale Ergebnisse sind die folgende:\\
	\begin{enumerate}
		\item Systemaufbau \\
		Das ganze System wurde zusammen mit der Hardware aufgebaut.
		\item Digitale Darstellung des Systemaufbaus\\
		Der Schaltplan des Systems wurde durch Fritzing digital dargestellt.
		\item Erkennung der Gesichter \\
		Es wurde eine Gesichtserkennung erreicht, die in 80 Prozent der Fälle funktioniert.
		\item Aufnahme der Benutzer Gesichtsdaten mithilfe der Emailadresse\\
		Gibt der Benutzer seine Emailadresse ein, werden die zugehörigen Gesichtsdaten von der Datenbank geladen, um den Vergleich zu machen.
	\end{enumerate}

\section{Was wurde gelernt und 
\textbf{welche
	 Verbesserungs
	 möglichkeiten gibt es}}

Während dieser Diplomarbeit wurde viel wichtiges gelernt und verstanden. Die wichtigsten Lektionen werden unten genannt und erklärt.\\
\begin{itemize}
	\item Zeitmanagement \\
	
	Die Wichtigkeit der Zeit wurde wirklich verstanden. Man hatte nicht mehr die Möglichkeit, Dinge immer für den letzte Moment zu lassen, weil es einfach zu viel ist. Ohne einen detaillierten Zeitplan und ohne eine systematische Arbeit würde dieses Projekt nicht fertig sein.
	
	\item Wie man mit OpenCV und mit Bilderdaten arbeitet\\
	
	Es wurde gelernt, wie man überhaupt mit Bildinformationen arbeitet, und wie das Paket OpenCV funktioniert. In Zukunft wenn es um Arbeiten mit Bilderdaten geht, ist das Basiswissen vorhanden.
	
	\item Wichtigkeit des Testens des Systems\\
	
	Wie wichtig der Test des Prozesses ist wurde auch hier verstanden. Vorher wurde gedacht, dass das Testen des Systems nur eine zusätzliche und unwichtige Arbeit ist. Es war aber nur mit Hilfe des Testens möglich, den Vergleichsprozess erfolgreich zu realisieren und Fehler zu finden. Ein System, das vorher nicht getestet wurde, kann kein gutes System sein.
	
	\item Gruppenarbeit und Verantwortlichkeiten übernehmen \\
	
	Die Rolle der Gruppe ist auch sehr wichtig. Geht es den Mitarbeitern miteinander gut und sie sind gut gelaunt, sind sie auch motivierter zum Arbeiten. Die Kommunikation soll nie fehlen und die Entscheidungen des Projektleiters sollen akzeptiert werden. Man muss auch seine Verantwortlichkeiten selbst übernehmen und seine Arbeit mit seiner Stärken erledigen. Das wurde alles auch während der Arbeit gelernt.
	
	\item Wichtigkeit der Planung und der Begrenzungen \\
	
	Es wurde schon gelernt, dass die Planung eines Projekts sehr wichtig war, aber mit Hilfe dieser Diplomarbeit wurde ganz genau verstanden, warum das so ist. Ohne die Big Pictures und die Erste Ebene wurde der Aufwand der Arbeit viel grösser, und die Zeit würde sicherlich nicht genügen. Die Begrenzungen sind auch wichtig, weil ohne die wurde man Zeit an etwas verlieren, das am Ende nicht realisierbar oder nicht nötig ist.
	
	\item Wie man mit Fehlern umgeht \\
	
	Außerdem wurde verstanden und gelernt, wie man mit Fehlern umgehen soll. Pessimismus und das Aufgeben sind nicht die Lösungen. Man muss optimistisch sein und viele verschiedene Wege suchen, wie man den Fehlern finden und dann reparieren kann. Fremde Hilfe ist auch irgendwann notwendig.
\end{itemize}	
	 Verbesserungsmöglichkeiten sind auch erkannt worden. Diese sind: 
\begin{itemize}	
	
	\item Besseres Zeitmanagement \\
	
	Die Arbeit musste ein bisschen früherer begonnen werden, und es muss besser verteilt werden. Es muss verstanden werden, dass sich hinter einem schlechten Projekt eine schlechte Zeitmanagement versteckt.
	
	\item Backup Verfahren \\
	
	Nächstes Mal wird die Arbeit öfter gespeichert. Back-Ups werden täglich gemacht, damit nichts verloren geht. Man denkt, dass das lokale Speichern genug ist. Was ist aber, wenn der PC kaputt wird? Das wird in die nächste Arbeiten berücksichtigt.
\end{itemize}

\chapter{Ausblick}
In diesem Kapitel wird kurz erkl\"art, was mit dem Projekt in der Zukunft passieren wird?
\section{Wie geht es weiter ?}
Dieses Projekt wird nicht in der Schule implementiert, weil die Schule es nicht angenommen hat. Dieses Projekt war zu kompliziert, um in die Schulinfrastruktur implementiert zu werden. Nach der Diploma Präsentation wird dieses Projekt abgeschlossen.
\section{Was passiert mit dem Ergebnis?}
Das Ergebnis wird von der Schule betrachtet, aber nichts besonders anders und nicht weiterentwickelt von dieser Gruppe.
\section{was passiert mit dem Prototyp?}
Der Prototyp wird im Lager der Schule eingeschlossen, da kein Interesse daran hat. 
\section{Gibt es Folgeprojekte?}
Momentan gibt es keine, aber die anderen Gruppen mit dem Schwerpunkt Systemtechnik können bzw. haben die Möglichkeit mit dem Projekt weiterzumachen.
\section{Gibt es Interessanten?}
Sowohl von der Schule als auch von anderen Unternehmen gibt es keine Interessengruppen, die dieses Projekt finanzieren möchten.